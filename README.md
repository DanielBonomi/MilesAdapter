
# Adapter Design Pattern for an Application for Navigation
## Author: Daniele Bonomi
Versión en español abajo.
This is the implementation of an Adapter adapting one measure system into another.
I looked online for a list of the 100 most populous cities in the USA and I put it in cities.csv. Then I built ResourceLoader.py, which finds the coordinates of the 100 cities using geopy.geocoders and calculates the distances between the cities in the USA. I had to use an external module to easily get the coordinates (latitude and longitude) and because calculating distances between points on a globe is non-trivial (and would have required quite some time). Please note that geopy sometimes fails due to connection errors: I've implemented an extra file to allow progress saving. With the distances calculated ResourceLoader create a graph where the cities are the nodes and the arcs are links between the cities. I chose to only keep the 10 shorter arcs but I made the graph undirected to allow full reachability from any city. ResourceLoader also has an option to read the distances from a json (which you can produce with the same ResourceLoader),  which I added to GitHub to allow to execute code without having geocode installed.
Then there are 3 classes: AmericanSystem, which performs navigation operations in miles, SpanishSystem which is an abstract class used as an interface and Adapter, which adapts AmericanSystem to the interface of SpanishSystem. The design patter is implemented as usually.
In AmericanSystem, I've implemented the path finder (I've implemented a simple Dijktra because I only needed to handle 100 cities), and a method that prints the path. Furthermore I've implemented a graphic interface to dinamically show the map of the USA with on it points of the cities in the path, as well as lines for the path itself. The graph also has a legend and shows the total path length in miles. For the graph I used geopanda with its dependencies matplotlib and shapely. I chose geopanda because it's the main library for geografical system that allows easy plots.
Thanks to the Adapter, the client (main in this case) can access AmericanSystem through the interface if SpanishSystem, and the final result is similar plot in the spanish language and using km instead of miles.
Executing main will ask as console input the start and goal city. I've added a function that looks through the cities to aid finding the cities. 


Esta es la implementación de un adaptador que adapta un sistema de medición a otro. Busqué en línea una lista de las 100 ciudades más pobladas de EE. UU. y la incluí en cities.csv. Luego creé ResourceLoader.py, que encuentra las coordenadas de las 100 ciudades usando geopy.geocoders y calcula las distancias entre las ciudades en EE. UU. Tuve que usar un módulo externo para obtener fácilmente las coordenadas (latitud y longitud) y porque calcular distancias entre puntos en un globo terráqueo no es trivial (y habría requerido bastante tiempo). Tenga en cuenta que geopy a veces falla debido a errores de conexión: He implementado un archivo adicional para permitir guardar el progreso. Con las distancias calculadas, ResourceLoader crea un gráfico donde las ciudades son los nodos y los arcos son los enlaces entre las ciudades. Elegí mantener solo los 10 arcos más cortos, pero hice que el gráfico no fuera dirigido para permitir la accesibilidad total desde cualquier ciudad. ResourceLoader también tiene una opción para leer las distancias desde un archivo JSON (que se puede generar con el mismo ResourceLoader), que añadí a GitHub para permitir la ejecución de código sin tener instalado el geocode. Además, hay tres clases: AmericanSystem, que realiza operaciones de navegación en millas; SpanishSystem, que es una clase abstracta que se usa como interfaz; y Adapter, que adapta AmericanSystem a la interfaz de SpanishSystem. El patrón de diseño se implementa como de costumbre. En AmericanSystem, he implementado el buscador de rutas (implementé un Dijktra simple porque solo necesitaba gestionar 100 ciudades) y un método que imprime la ruta. Además, he implementado una interfaz gráfica para mostrar dinámicamente el mapa de EE. UU. con los puntos de las ciudades en la ruta, así como líneas para la ruta misma. El gráfico también tiene una leyenda y muestra la longitud total de la ruta en millas. Para el gráfico, usé Geopanda con sus dependencias matplotlib y shapely. Elegí Geopanda porque es la biblioteca principal para sistemas geográficos que permite crear gráficos fácilmente. Gracias al adaptador, el cliente (main en este caso) puede acceder a AmericanSystem a través de la interfaz de SpanishSystem, y el resultado final es un gráfico similar en español, utilizando kilómetros en lugar de millas. Al ejecutar main, se solicitarán como entrada de consola las ciudades de inicio y de destino. He añadido al main una función para facilitar la búsqueda de las ciudades.
